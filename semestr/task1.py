import numpy as np
import matplotlib.pyplot as plt


# Исходная функция f(x) = x*sin(x^2 + x)
# Функция осциллирует с увеличивающейся частотой, что делает её непростой для интерполяции
def f(x):
    return x * np.sin(x ** 2 + x)


# ЛИНЕЙНЫЙ СПЛАЙН (сплайн 1-й степени)
# Математическая идея: на каждом интервале [x_i, x_{i+1}] строим обычную прямую (линейную функцию)
# Условия: в узлах интерполяции значения сплайна совпадают со значениями функции
def linear_spline(x_nodes, y_nodes, x):
    n = len(x_nodes) - 1  # количество интервалов

    # Ищем, в каком интервале находится точка x
    for i in range(n):
        if x_nodes[i] <= x <= x_nodes[i + 1]:
            # Формула линейной интерполяции на отрезке [x_i, x_{i+1}]:
            # S(x) = y_i + (y_{i+1} - y_i)/(x_{i+1} - x_i) * (x - x_i)
            # Это уравнение прямой, проходящей через две точки (x_i, y_i) и (x_{i+1}, y_{i+1})
            return y_nodes[i] + (y_nodes[i + 1] - y_nodes[i]) / (x_nodes[i + 1] - x_nodes[i]) * (x - x_nodes[i])

    # Если x вне диапазона узлов, используем крайние отрезки
    # (экстраполяция с помощью ближайшего линейного сегмента)
    if x < x_nodes[0]:
        return y_nodes[0] + (y_nodes[1] - y_nodes[0]) / (x_nodes[1] - x_nodes[0]) * (x - x_nodes[0])
    else:
        return y_nodes[-2] + (y_nodes[-1] - y_nodes[-2]) / (x_nodes[-1] - x_nodes[-2]) * (x - x_nodes[-2])


# ПАРАБОЛИЧЕСКИЙ СПЛАЙН (сплайн 2-й степени)
# Математическая идея: на каждом интервале [x_i, x_{i+1}] строим параболу вида:
# S_i(x) = a_i*x^2 + b_i*x + c_i
# Условия:
# 1. S_i(x_i) = y_i (значения в левых концах интервалов)
# 2. S_i(x_{i+1}) = y_{i+1} (значения в правых концах)
# 3. S_i'(x_{i+1}) = S_{i+1}'(x_{i+1}) (совпадение первых производных во внутренних узлах)
# 4. S_0''(x_0) = 0 (естественное граничное условие - вторая производная в начале равна 0)
def parabolic_spline(x_nodes, y_nodes):
    n = len(x_nodes) - 1  # количество интервалов

    # Для каждого интервала у нас 3 коэффициента: a, b, c
    a = np.zeros(n)  # коэффициенты при x^2
    b = np.zeros(n)  # коэффициенты при x
    c = np.zeros(n)  # свободные члены

    # Строим систему линейных уравнений размером 3n x 3n
    # (так как у нас n парабол и у каждой 3 коэффициента)
    A = np.zeros((3 * n, 3 * n))  # матрица коэффициентов системы
    rhs = np.zeros(3 * n)  # правая часть системы

    # УСЛОВИЕ 1 и 2: совпадение значений в узлах
    # Для каждой параболы i на интервале [x_i, x_{i+1}]
    for i in range(n):
        # Левое условие: S_i(x_i) = y_i
        # a_i*x_i^2 + b_i*x_i + c_i = y_i
        row_idx = i  # строка для левого условия параболы i
        A[row_idx, 3 * i] = x_nodes[i] ** 2  # коэффициент при a_i
        A[row_idx, 3 * i + 1] = x_nodes[i]  # коэффициент при b_i
        A[row_idx, 3 * i + 2] = 1  # коэффициент при c_i
        rhs[row_idx] = y_nodes[i]  # правая часть

        # Правое условие: S_i(x_{i+1}) = y_{i+1}
        # a_i*x_{i+1}^2 + b_i*x_{i+1} + c_i = y_{i+1}
        row_idx = n + i  # строка для правого условия параболы i
        A[row_idx, 3 * i] = x_nodes[i + 1] ** 2  # коэффициент при a_i
        A[row_idx, 3 * i + 1] = x_nodes[i + 1]  # коэффициент при b_i
        A[row_idx, 3 * i + 2] = 1  # коэффициент при c_i
        rhs[row_idx] = y_nodes[i + 1]  # правая часть

    # УСЛОВИЕ 3: непрерывность первых производных во внутренних узлах
    # Производная параболы: S_i'(x) = 2*a_i*x + b_i
    # Условие: S_i'(x_{i+1}) = S_{i+1}'(x_{i+1})
    # => 2*a_i*x_{i+1} + b_i = 2*a_{i+1}*x_{i+1} + b_{i+1}
    for i in range(n - 1):
        row_idx = 2 * n + i  # строка для условия непрерывности производной в узле x_{i+1}

        # Левая часть: S_i'(x_{i+1}) = 2*a_i*x_{i+1} + b_i
        A[row_idx, 3 * i] = 2 * x_nodes[i + 1]  # коэффициент при a_i
        A[row_idx, 3 * i + 1] = 1  # коэффициент при b_i

        # Правая часть (перенесена влево): -S_{i+1}'(x_{i+1}) = -2*a_{i+1}*x_{i+1} - b_{i+1}
        A[row_idx, 3 * (i + 1)] = -2 * x_nodes[i + 1]  # коэффициент при a_{i+1}
        A[row_idx, 3 * (i + 1) + 1] = -1  # коэффициент при b_{i+1}

        # Коэффициенты при c_i и c_{i+1} равны 0 (c не входит в производную)
        rhs[row_idx] = 0  # правая часть уравнения: 2*a_i*x_{i+1} + b_i - 2*a_{i+1}*x_{i+1} - b_{i+1} = 0

    # УСЛОВИЕ 4: естественное граничное условие (вторая производная в начале равна 0)
    # Вторая производная параболы: S_0''(x) = 2*a_0
    # Условие: S_0''(x_0) = 0 => 2*a_0 = 0
    row_idx = 3 * n - 1  # последняя строка системы
    A[row_idx, 0] = 2  # коэффициент при a_0
    # Остальные коэффициенты в этой строке остаются 0
    rhs[row_idx] = 0  # правая часть: 2*a_0 = 0

    # Решаем систему линейных уравнений
    # A * coeffs = rhs, где coeffs - вектор всех коэффициентов [a0, b0, c0, a1, b1, c1, ...]
    coeffs = np.linalg.lstsq(A, rhs, rcond=None)[0]

    # Извлекаем коэффициенты для каждой параболы
    for i in range(n):
        a[i] = coeffs[3 * i]  # коэффициент a_i
        b[i] = coeffs[3 * i + 1]  # коэффициент b_i
        c[i] = coeffs[3 * i + 2]  # коэффициент c_i

    return a, b, c


# Вычисление значения параболического сплайна в точке x
def eval_parabolic_spline(x_nodes, coeffs, x):
    a, b, c = coeffs
    n = len(x_nodes) - 1

    # Ищем интервал, в который попадает точка x
    for i in range(n):
        if x_nodes[i] <= x <= x_nodes[i + 1]:
            # Вычисляем значение параболы: S_i(x) = a_i*x^2 + b_i*x + c_i
            return a[i] * x ** 2 + b[i] * x + c[i]

    # Если точка вне диапазона, используем ближайшую параболу
    if x < x_nodes[0]:
        return a[0] * x ** 2 + b[0] * x + c[0]
    else:
        return a[-1] * x ** 2 + b[-1] * x + c[-1]


# КУБИЧЕСКИЙ СПЛАЙН (сплайн 3-й степени) - естественный сплайн
# Математическая идея: на каждом интервале [x_i, x_{i+1}] строим кубический полином:
# S_i(x) = a_i + b_i*(x - x_i) + c_i*(x - x_i)^2 + d_i*(x - x_i)^3
# Условия:
# 1. S_i(x_i) = y_i (совпадение значений в узлах)
# 2. S_i(x_{i+1}) = y_{i+1} (совпадение значений в узлах)
# 3. S_i'(x_{i+1}) = S_{i+1}'(x_{i+1}) (непрерывность первых производных)
# 4. S_i''(x_{i+1}) = S_{i+1}''(x_{i+1}) (непрерывность вторых производных)
# 5. S_0''(x_0) = 0 и S_n''(x_n) = 0 (естественные граничные условия)
def cubic_spline(x_nodes, y_nodes):
    n = len(x_nodes) - 1  # количество интервалов
    h = np.diff(x_nodes)  # длины интервалов: h_i = x_{i+1} - x_i

    # Матрица для нахождения вторых производных M_i = S_i''(x_i)
    # Размер матрицы: (n+1) x (n+1), где n+1 - количество узлов
    A = np.zeros((n + 1, n + 1))
    b_vec = np.zeros(n + 1)

    # ЕСТЕСТВЕННЫЕ ГРАНИЧНЫЕ УСЛОВИЯ (условие 5)
    # S_0''(x_0) = 0 => M_0 = 0
    A[0, 0] = 1  # M_0 = 0

    # S_n''(x_n) = 0 => M_n = 0
    A[n, n] = 1  # M_n = 0

    # Уравнения для внутренних узлов (условия 1-4 приводят к системе):
    # h_{i-1}*M_{i-1} + 2*(h_{i-1} + h_i)*M_i + h_i*M_{i+1} =
    # = 3*[(y_{i+1} - y_i)/h_i - (y_i - y_{i-1})/h_{i-1}]
    for i in range(1, n):
        A[i, i - 1] = h[i - 1]  # коэффициент при M_{i-1}
        A[i, i] = 2 * (h[i - 1] + h[i])  # коэффициент при M_i
        A[i, i + 1] = h[i]  # коэффициент при M_{i+1}

        # Правая часть: разделенные разности
        b_vec[i] = 3 * ((y_nodes[i + 1] - y_nodes[i]) / h[i] - (y_nodes[i] - y_nodes[i - 1]) / h[i - 1])

    # Решаем систему для вторых производных M_i в узлах
    M = np.linalg.solve(A, b_vec)  # M - вектор вторых производных в узлах

    # Вычисляем коэффициенты кубических полиномов для каждого интервала
    a = np.zeros(n)  # свободные члены (a_i = y_i)
    b = np.zeros(n)  # коэффициенты при (x - x_i)
    c = np.zeros(n)  # коэффициенты при (x - x_i)^2
    d = np.zeros(n)  # коэффициенты при (x - x_i)^3

    for i in range(n):
        # a_i = y_i (из условия S_i(x_i) = y_i)
        a[i] = y_nodes[i]

        # b_i вычисляется из условий непрерывности:
        b[i] = (y_nodes[i + 1] - y_nodes[i]) / h[i] - h[i] * (2 * M[i] + M[i + 1]) / 3

        # c_i = M_i / 2 (так как S_i''(x_i) = 2*c_i + 6*d_i*(x - x_i), при x = x_i: S_i''(x_i) = 2*c_i)
        # Но в нашей параметризации c_i = M_i / 2, а здесь мы сохраняем M_i как есть
        c[i] = M[i]  # в этой параметризации c_i = M_i

        # d_i вычисляется из условий на производные:
        d[i] = (M[i + 1] - M[i]) / (3 * h[i])

    return a, b, c, d


# Вычисление значения кубического сплайна в точке x
def eval_cubic_spline(x_nodes, coeffs, x):
    a, b, c, d = coeffs
    n = len(x_nodes) - 1

    # Ищем интервал, в который попадает точка x
    for i in range(n):
        if x_nodes[i] <= x <= x_nodes[i + 1]:
            dx = x - x_nodes[i]  # смещение относительно левого конца интервала
            # Вычисляем значение кубического полинома:
            # S_i(x) = a_i + b_i*dx + c_i*dx^2 + d_i*dx^3
            return a[i] + b[i] * dx + c[i] * dx ** 2 + d[i] * dx ** 3

    # Если точка вне диапазона, используем ближайший кубический полином
    if x < x_nodes[0]:
        dx = x - x_nodes[0]
        return a[0] + b[0] * dx + c[0] * dx ** 2 + d[0] * dx ** 3
    else:
        dx = x - x_nodes[-2]
        return a[-1] + b[-1] * dx + c[-1] * dx ** 2 + d[-1] * dx ** 3

# ОСНОВНЫЕ ОТЛИЧИЯ МЕЖДУ СПЛАЙНАМИ:
#
# 1. ЛИНЕЙНЫЙ СПЛАЙН (степень 1):
#    - Простейший сплайн, состоит из отрезков прямых
#    - Непрерывен, но имеет изломы в узлах (первая производная разрывна)
#    - Точность: O(h^2), где h - максимальная длина интервала
#
# 2. ПАРАБОЛИЧЕСКИЙ СПЛАЙН (степень 2):
#    - Состоит из отрезков парабол
#    - Непрерывен и имеет непрерывную первую производную
#    - Вторая производная может быть разрывной
#    - Точность: O(h^3)
#
# 3. КУБИЧЕСКИЙ СПЛАЙН (степень 3):
#    - Состоит из отрезков кубических полиномов
#    - Непрерывен, имеет непрерывные первую и вторую производные
#    - Самый гладкий из рассматриваемых сплайнов
#    - Точность: O(h^4)
#    - Естественный сплайн: вторая производная на концах равна 0
#
# ПРАКТИЧЕСКИЕ СОВЕТЫ:
# - Линейный сплайн: когда важна простота, а гладкость не критична
# - Кубический сплайн: когда нужна высокая точность и гладкость
# - Параболический сплайн: компромисс между простотой и точностью