# Импорт необходимых библиотек
import matplotlib

matplotlib.use('TkAgg')  # Установка бэкенда для отображения графиков
import matplotlib.pyplot as plt  # Библиотека для построения графиков
from sympy import symbols, sin, diff  # Sympy для символьных вычислений
import numpy as np  # Библиотека для численных вычислений


def lagrange(x, xs, ys):
    """
    Вычисляет значение полинома Лагранжа в точке x

    Параметры:
    x - точка, в которой вычисляется значение
    xs - массив узлов интерполяции
    ys - массив значений функции в узлах

    Алгоритм:
    L(x) = Σ [y_i * l_i(x)], где l_i(x) = Π [(x - x_j)/(x_i - x_j)] для j ≠ i
    """
    s = 0  # Инициализация суммы
    n = len(xs)  # Количество узлов интерполяции

    # Цикл по всем узлам интерполяции
    for i in range(n):
        p = 1  # Инициализация произведения для базисного полинома Лагранжа

        # Вычисление базисного полинома l_i(x)
        for j in range(n):
            if i == j:
                continue  # Пропускаем случай i = j
            # Вычисление множителя (x - x_j)/(x_i - x_j)
            p *= (x - xs[j]) / (xs[i] - xs[j])

        # Добавляем слагаемое y_i * l_i(x) к общей сумме
        s += ys[i] * p

    return s


def factorial(n):
    """
    Рекурсивное вычисление факториала числа n

    Факториал используется в формуле для оценки погрешности интерполяции
    n! = 1 * 2 * 3 * ... * n
    """
    if n == 0:
        return 1  # Базовый случай: 0! = 1
    else:
        return n * factorial(n - 1)  # Рекурсивный вызов


# ========== НАСТРОЙКИ ИНТЕРПОЛЯЦИИ ==========
n = 13  # Степень полинома Лагранжа (количество узлов = n + 1 = 14)
a, b = 0, 2  # Отрезок интерполяции [0, 2]

# ========== ПОДГОТОВКА ДАННЫХ ==========

# Создание массива из 1000 точек на отрезке [0, 2] для построения гладких графиков
xs = np.linspace(a, b, 1000)

# Вычисление значений исходной функции f(x) = x * sin(x² + x) во всех точках
# x * sin(x² + x) - наша интерполируемая функция
ys = xs * np.sin(xs ** 2 + xs)

# Создание равномерно распределенных узлов интерполяции
# n+1 узлов на отрезке [0, 2]
x_nodes = np.linspace(a, b, n + 1)

# Вычисление значений функции в узлах интерполяции
y_nodes = x_nodes * np.sin(x_nodes ** 2 + x_nodes)

# ========== ВЫЧИСЛЕНИЕ ПОЛИНОМА ЛАГРАНЖА ==========

# Вычисление значений полинома Лагранжа во всех точках xs
# Для каждой точки x_ в xs вычисляем L_n(x_) - значение полинома Лагранжа
yl = [lagrange(x_, x_nodes, y_nodes) for x_ in xs]

# ========== ПОСТРОЕНИЕ ГРАФИКОВ ФУНКЦИЙ ==========

plt.figure(figsize=(10, 6))  # Создание фигуры размером 10x6 дюймов

# График исходной функции - сплошная линия
plt.plot(xs, ys, label="Действительная функция", linewidth=2)

# Узлы интерполяции - черные точки
plt.plot(x_nodes, y_nodes, "o", color='black', label="Узлы интерполяции", markersize=6)

# График полинома Лагранжа - красная пунктирная линия
plt.plot(xs, yl, ls="--", c="r", label="Полином Лагранжа")

plt.legend()  # Отображение легенды
plt.xlabel("x")  # Подпись оси X
plt.ylabel("y")  # Подпись оси Y
plt.title("Интерполяция Лагранжа для функции $x \cdot \sin(x^2 + x)$")  # Заголовок
plt.grid(True, alpha=0.3)  # Включение сетки с прозрачностью 30%
plt.xlim(0, 2)  # Ограничение области просмотра по оси X
plt.show()  # Отображение графика

# ========== ВЫЧИСЛЕНИЕ ПОГРЕШНОСТЕЙ ==========

# Создание символьной переменной для аналитических вычислений
xxx = symbols('x')

# Определение функции в символьном виде для вычисления производных
f = xxx * sin(xxx ** 2 + xxx)

# ПРАКТИЧЕСКАЯ ПОГРЕШНОСТЬ
# Вычисление модуля разности между истинными значениями и интерполяцией
rn = abs(ys - yl)
# Максимальная практическая погрешность на всем отрезке
max_practical_error = max(rn)

# ТЕОРЕТИЧЕСКАЯ ПОГРЕШНОСТЬ
# Вычисление (n+1)-й производной функции (для n=13 это 14-я производная)
df = diff(f, xxx, n + 1)

rnt = []  # Список для хранения теоретических погрешностей
# Вычисление теоретической погрешности для каждой точки
for z in xs:
    # Вычисление произведения Π (z - x_k) - многочлен узлов
    prod_term = 1
    for xk in x_nodes:
        prod_term *= (z - xk)

    # Вычисление значения (n+1)-й производной в точке z
    df_val = abs(df.subs(xxx, z))

    # Формула для оценки погрешности интерполяции:
    # R_n(x) = |f(x) - L_n(x)| ≤ |f^(n+1)(ξ)|/(n+1)! * |Π (x - x_i)|
    # где ξ ∈ [a,b]
    error = df_val / factorial(n + 1) * abs(prod_term)
    rnt.append(error)

# Максимальная теоретическая погрешность
max_theoretical_error = max(rnt)

# ========== ВЫВОД РЕЗУЛЬТАТОВ ==========
print(f'Максимальная практическая погрешность: {max_practical_error:.6e}')
print(f'Максимальная теоретическая погрешность: {max_theoretical_error:.6e}')

# ========== ПОСТРОЕНИЕ ГРАФИКОВ ПОГРЕШНОСТЕЙ ==========
plt.figure(figsize=(10, 6))

# График практической погрешности - magenta цвет
plt.plot(xs, rn, color='red', label="Практическая погрешность", linewidth=2)

# График теоретической погрешности - orange цвет
plt.plot(xs, rnt, color='blue', label="Теоретическая погрешность", linewidth=2)

plt.xlabel("x")
plt.ylabel("Погрешность")
plt.legend()
plt.title("Погрешности интерполяции для функции $x \cdot \sin(x^2 + x)$")
plt.grid(True, alpha=0.3)

plt.xlim(0, 2)  # Ограничение по оси X
plt.show()